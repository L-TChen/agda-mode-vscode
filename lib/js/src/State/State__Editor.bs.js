// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Goal$AgdaModeVscode = require("../Goal.bs.js");
var State$AgdaModeVscode = require("./State.bs.js");
var TaskQueue$AgdaModeVscode = require("./TaskQueue.bs.js");
var State__View$AgdaModeVscode = require("./State__View.bs.js");

function Impl(Editor) {
  var State = State$AgdaModeVscode.Impl(Editor);
  var Goal = Goal$AgdaModeVscode.Impl(Editor);
  var ViewM = State__View$AgdaModeVscode.Impl(Editor);
  var getOffsets = function (state) {
    return Belt_Array.map(state.goals, (function (goal) {
                  return goal.range[0] + 3 | 0;
                }));
  };
  var pointingAt = function (cursor, state) {
    var cursorOffset = cursor !== undefined ? cursor : Curry._2(Editor.offsetAtPoint, state.editor, Curry._1(Editor.getCursorPosition, state.editor));
    var pointedGoals = Belt_Array.keep(state.goals, (function (goal) {
            if (goal.range[0] <= cursorOffset) {
              return cursorOffset <= goal.range[1];
            } else {
              return false;
            }
          }));
    return Belt_Array.get(pointedGoals, 0);
  };
  var indentationWidth = function (goal, editor) {
    var goalStart = Curry._2(Editor.pointAtOffset, editor, goal.range[0]);
    var lineNo = Curry._1(Editor.Point.line, goalStart);
    var range = Curry._2(Editor.$$Range.make, Curry._2(Editor.Point.make, lineNo, 0), goalStart);
    var textBeforeGoal = Curry._2(Editor.getTextInRange, editor, range);
    var indentedBy = function (s) {
      var n = 0;
      for(var i = 0 ,i_finish = s.length; i < i_finish; ++i){
        var match = s.charAt(i);
        var exit = 0;
        switch (match) {
          case "\t" :
          case "\n" :
          case "\f" :
          case "\r" :
          case " " :
              exit = 1;
              break;
          default:
            
        }
        if (exit === 1 && i === n) {
          n = n + 1 | 0;
        }
        
      }
      return n;
    };
    return /* tuple */[
            indentedBy(textBeforeGoal),
            textBeforeGoal,
            range
          ];
  };
  var saveEditor = function (state) {
    return $$Promise.map(Curry._1(Editor.save, state.editor), (function (param) {
                  return state;
                }));
  };
  var setText = function (range, content, state) {
    return $$Promise.map(TaskQueue$AgdaModeVscode.add(state.editorTaskQueue, (function (param) {
                      console.log("==== START  ");
                      return $$Promise.map($$Promise.tap(Curry._3(Editor.setText, state.editor, range, content), (function (param) {
                                        console.log(" - - END  ");
                                        
                                      })), (function (param) {
                                    if (param) {
                                      return ;
                                    } else {
                                      console.log("EditM.setText failed");
                                      return ;
                                    }
                                  }));
                    })), (function (param) {
                  return state;
                }));
  };
  var saveCursor = function (state) {
    var position = Curry._1(Editor.getCursorPosition, state.editor);
    var offset = Curry._2(Editor.offsetAtPoint, state.editor, position);
    state.cursor = offset;
    return $$Promise.resolved(state);
  };
  var restoreCursor = function (state) {
    var offset = state.cursor;
    if (offset !== undefined) {
      state.cursor = undefined;
      var position = Curry._2(Editor.pointAtOffset, state.editor, offset);
      var pointedGoal = pointingAt(offset, state);
      if (pointedGoal !== undefined) {
        if (Curry._2(Goal.getContent, pointedGoal, state.editor) === "") {
          Curry._2(Goal.setCursor, pointedGoal, state.editor);
        } else {
          Curry._2(Editor.setCursorPosition, state.editor, position);
        }
      } else {
        Curry._2(Editor.setCursorPosition, state.editor, position);
        Curry._1(Editor.focus, state.editor);
      }
    }
    return $$Promise.resolved(state);
  };
  var setCursor = function (offset, state) {
    var point = Curry._2(Editor.pointAtOffset, state.editor, offset);
    Curry._2(Editor.setCursorPosition, state.editor, point);
    return $$Promise.resolved(state);
  };
  var instantiateGoals = function (indices, state) {
    Belt_Array.forEach(state.goals, Goal.destroy);
    return $$Promise.map(Curry._3(Goal.makeMany, state.editor, (function (text, range) {
                      return $$Promise.map(setText(text, range, state), (function (param) {
                                    
                                  }));
                    }), indices), (function (goals) {
                  state.goals = goals;
                  return state;
                }));
  };
  var nextGoal = function (state) {
    Curry._2(Goal.updateRanges, state.goals, state.editor);
    var nextGoal$1 = {
      contents: undefined
    };
    var cursorOffset = Curry._2(Editor.offsetAtPoint, state.editor, Curry._1(Editor.getCursorPosition, state.editor));
    var offsets = getOffsets(state);
    Belt_Array.forEach(offsets, (function (offset) {
            if (cursorOffset < offset && nextGoal$1.contents === undefined) {
              nextGoal$1.contents = offset;
              return ;
            }
            
          }));
    if (nextGoal$1.contents === undefined) {
      nextGoal$1.contents = Belt_Array.get(offsets, 0);
    }
    var offset = nextGoal$1.contents;
    if (offset !== undefined) {
      Curry._2(Editor.setCursorPosition, state.editor, Curry._2(Editor.pointAtOffset, state.editor, offset));
      return $$Promise.resolved(state);
    } else {
      return $$Promise.resolved(state);
    }
  };
  var previousGoal = function (state) {
    Curry._2(Goal.updateRanges, state.goals, state.editor);
    var previousGoal$1 = {
      contents: undefined
    };
    var cursorOffset = Curry._2(Editor.offsetAtPoint, state.editor, Curry._1(Editor.getCursorPosition, state.editor));
    var offsets = getOffsets(state);
    Belt_Array.forEach(offsets, (function (offset) {
            if (cursorOffset > offset) {
              previousGoal$1.contents = offset;
              return ;
            }
            
          }));
    if (previousGoal$1.contents === undefined) {
      previousGoal$1.contents = Belt_Array.get(offsets, offsets.length - 1 | 0);
    }
    var offset = previousGoal$1.contents;
    if (offset !== undefined) {
      Curry._2(Editor.setCursorPosition, state.editor, Curry._2(Editor.pointAtOffset, state.editor, offset));
      return $$Promise.resolved(state);
    } else {
      return $$Promise.resolved(state);
    }
  };
  var modifyGoal = function (goal, f, state) {
    Curry._2(Goal.updateRanges, state.goals, state.editor);
    var content = Curry._2(Goal.getContent, goal, state.editor);
    console.log("[ goal ][ modify ] \"" + (content + ("\" => \"" + (Curry._1(f, content) + "\""))));
    return $$Promise.map(Curry._4(Goal.setContent, goal, state.editor, (function (range, text) {
                      return $$Promise.map(setText(range, text, state), (function (param) {
                                    
                                  }));
                    }), Curry._1(f, content)), (function (param) {
                  return state;
                }));
  };
  var removeBoundaryAndDestroyGoal = function (goal, state) {
    Curry._2(Goal.updateRanges, state.goals, state.editor);
    var innerRange = Curry._2(Goal.getInnerRange, goal, state.editor);
    var outerRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.pointAtOffset, state.editor, goal.range[0]), Curry._2(Editor.pointAtOffset, state.editor, goal.range[1]));
    var content = $$String.trim(Curry._2(Editor.getTextInRange, state.editor, innerRange));
    return $$Promise.tap(setText(outerRange, content, state), (function (param) {
                  return Curry._1(Goal.destroy, goal);
                }));
  };
  var replaceWithLines = function (goal, lines, state) {
    var match = indentationWidth(goal, state.editor);
    var indentation = " ".repeat(match[0]);
    var indentedLines = indentation + lines.join("\n" + indentation);
    console.log("[ReplaceWithLines]");
    console.log(indentedLines);
    console.log("=================");
    var start = Curry._2(Editor.pointAtOffset, state.editor, goal.range[0]);
    var startLineNo = Curry._1(Editor.Point.line, start);
    var startLineRange = Curry._2(Editor.rangeForLine, state.editor, startLineNo);
    var start$1 = Curry._1(Editor.$$Range.start, startLineRange);
    var end_ = Curry._2(Editor.pointAtOffset, state.editor, goal.range[1]);
    var rangeToBeReplaced = Curry._2(Editor.$$Range.make, start$1, end_);
    console.log("[rangeToBeReplaced]");
    console.log(rangeToBeReplaced);
    console.log("=================");
    return $$Promise.flatMap(Curry._3(Editor.setText, state.editor, rangeToBeReplaced, indentedLines), (function (param) {
                  if (param) {
                    Curry._1(Goal.destroy, goal);
                    return $$Promise.resolved(state);
                  } else {
                    return Curry._3(ViewM.displayError, "Goal-related Error", "Unable to replace the lines of goal #" + String(goal.index), state);
                  }
                }));
  };
  var replaceWithLambda = function (goal, lines, state) {
    var goalEnd = Curry._2(Editor.pointAtOffset, state.editor, goal.range[1]);
    var match = indentationWidth(goal, state.editor);
    var range = match[2];
    var textBeforeGoal = match[1];
    var indentWidth = match[0];
    var scanRow = Curry._1(Editor.Point.line, Curry._1(Editor.$$Range.start, range));
    var n = textBeforeGoal.lastIndexOf(";");
    var scanColStart = n !== -1 ? n + 1 | 0 : indentWidth;
    var scanColEnd = Curry._1(Editor.Point.column, Curry._1(Editor.$$Range.end_, range));
    var bracketCount = 0;
    var i = scanColEnd - 1 | 0;
    while(i >= scanColStart && bracketCount >= 0) {
      var i$prime = i;
      if (i$prime !== 0) {
        var match$1 = textBeforeGoal.charAt(i$prime - 1 | 0);
        switch (match$1) {
          case "{" :
              bracketCount = bracketCount - 1 | 0;
              break;
          case "}" :
              bracketCount = bracketCount + 1 | 0;
              break;
          default:
            
        }
      }
      i = i - 1 | 0;
    };
    console.log(/* tuple */[
          textBeforeGoal,
          i + 1 | 0,
          indentWidth
        ]);
    var rewriteRange = Curry._2(Editor.$$Range.make, Curry._2(Editor.Point.make, scanRow, i + 1 | 0), goalEnd);
    var isLambdaWhere = (i + 1 | 0) === indentWidth;
    var rewriteText = isLambdaWhere ? lines.join("\n" + " ".repeat(indentWidth)) : " " + lines.join("\n" + (" ".repeat(indentWidth) + "; "));
    return $$Promise.flatMap(Curry._3(Editor.setText, state.editor, rewriteRange, rewriteText), (function (param) {
                  if (param) {
                    Curry._1(Goal.destroy, goal);
                    return $$Promise.resolved(state);
                  } else {
                    return Curry._3(ViewM.displayError, "Goal-related Error", "Unable to replace the lines of goal #" + String(goal.index), state);
                  }
                }));
  };
  var localOrGlobal = function (local, $$global, state) {
    Curry._2(Goal.updateRanges, state.goals, state.editor);
    var goal = pointingAt(undefined, state);
    if (goal !== undefined) {
      return Curry._1(local, goal);
    } else {
      return $$global;
    }
  };
  var localOrGlobal2 = function (local, localEmpty, $$global, state) {
    var goal = pointingAt(undefined, state);
    if (goal === undefined) {
      return $$global;
    }
    var content = Curry._2(Goal.getContent, goal, state.editor);
    if (content === "") {
      return Curry._1(localEmpty, goal);
    } else {
      return Curry._2(local, goal, content);
    }
  };
  return {
          State: State,
          Goal: Goal,
          ViewM: ViewM,
          getOffsets: getOffsets,
          pointingAt: pointingAt,
          indentationWidth: indentationWidth,
          saveEditor: saveEditor,
          setText: setText,
          saveCursor: saveCursor,
          restoreCursor: restoreCursor,
          setCursor: setCursor,
          instantiateGoals: instantiateGoals,
          nextGoal: nextGoal,
          previousGoal: previousGoal,
          modifyGoal: modifyGoal,
          removeBoundaryAndDestroyGoal: removeBoundaryAndDestroyGoal,
          replaceWithLines: replaceWithLines,
          replaceWithLambda: replaceWithLambda,
          localOrGlobal: localOrGlobal,
          localOrGlobal2: localOrGlobal2
        };
}

var Js$prime;

var Js;

exports.Js$prime = Js$prime;
exports.Js = Js;
exports.Impl = Impl;
/* Promise Not a pure module */
