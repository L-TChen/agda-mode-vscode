// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var $$Promise = require("reason-promise/lib/js/src/js/promise.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Task$AgdaModeVscode = require("./Task.bs.js");
var Caml_chrome_debugger = require("bs-platform/lib/js/caml_chrome_debugger.js");
var Response$AgdaModeVscode = require("../Response.bs.js");
var Decoration$AgdaModeVscode = require("../Decoration.bs.js");
var MultiQueue$AgdaModeVscode = require("./MultiQueue.bs.js");
var Handle__Goal$AgdaModeVscode = require("./Handle__Goal.bs.js");
var Handle__Error$AgdaModeVscode = require("./Handle__Error.bs.js");
var Handle__Command$AgdaModeVscode = require("./Handle__Command.bs.js");
var Handle__Response$AgdaModeVscode = require("./Handle__Response.bs.js");
var State__Connection$AgdaModeVscode = require("../State/State__Connection.bs.js");

function Impl(Editor) {
  var Decoration = Decoration$AgdaModeVscode.Impl(Editor);
  var ConnM = State__Connection$AgdaModeVscode.Impl(Editor);
  var ErrorHandler = Handle__Error$AgdaModeVscode.Impl(Editor);
  var GoalHandler = Handle__Goal$AgdaModeVscode.Impl(Editor);
  var CommandHandler = Handle__Command$AgdaModeVscode.Impl(Editor);
  var ResponseHandler = Handle__Response$AgdaModeVscode.Impl(Editor);
  var Task = Task$AgdaModeVscode.Impl(Editor);
  var sendAgdaRequest = function (runTasks, runTasksLater, state, req) {
    var match = $$Promise.pending(undefined);
    var resolve = match[1];
    var promise = match[0];
    var handle = {
      contents: undefined
    };
    var handler = function (error) {
      if (error.tag) {
        return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Connection */Caml_chrome_debugger.variant("Connection", 0, [error[0]])));
      }
      var match = error[0];
      if (match) {
        var error$1 = match[0];
        if (error$1.tag) {
          return Curry._1(runTasks, Curry._1(ErrorHandler.handle, /* Parser */Caml_chrome_debugger.variant("Parser", 1, [error$1[0]])));
        }
        var response = error$1[0];
        if (response.tag) {
          var response$1 = response[1];
          var priority = response[0];
          console.log(">>> " + (String(priority) + (" " + Response$AgdaModeVscode.toString(response$1))));
          var tasks = Curry._1(ResponseHandler.handle, response$1);
          return Curry._2(runTasksLater, priority, tasks);
        }
        var response$2 = response[0];
        console.log(">>> " + Response$AgdaModeVscode.toString(response$2));
        return Curry._1(runTasks, Curry._1(ResponseHandler.handle, response$2));
      }
      console.log(">>| ");
      return Curry._1(resolve, undefined);
    };
    return $$Promise.tap($$Promise.flatMap(Curry._2(ConnM.sendRequestToAgda, state, req), (function (connection) {
                      if (connection.tag) {
                        var tasks = Curry._1(ErrorHandler.handle, connection[0]);
                        Curry._1(runTasks, tasks);
                        return promise;
                      }
                      handle.contents = Curry._1(connection[0].emitter.on, handler);
                      return promise;
                    })), (function (param) {
                  return Belt_Option.forEach(handle.contents, (function (f) {
                                return Curry._1(f, undefined);
                              }));
                }));
  };
  var log = function (param) {
    
  };
  var make = function (param) {
    return {
            queues: MultiQueue$AgdaModeVscode.make(undefined),
            busy: false
          };
  };
  var spawn = function (self, target) {
    self.queues = MultiQueue$AgdaModeVscode.spawn(self.queues, target);
    
  };
  var remove = function (self, target) {
    self.queues = MultiQueue$AgdaModeVscode.remove(self.queues, target);
    
  };
  var addTasks = function (self, target, tasks) {
    self.queues = MultiQueue$AgdaModeVscode.addTasks(self.queues, target, tasks);
    
  };
  var countBySource = function (self, target) {
    return MultiQueue$AgdaModeVscode.countBySource(self.queues, target);
  };
  var getNextTask = function (self) {
    return Belt_Option.map(MultiQueue$AgdaModeVscode.getNextTask(true, self.queues), (function (param) {
                  self.queues = param[1];
                  return param[0];
                }));
  };
  var addMiscTasks = function (self, tasks) {
    spawn(self, /* Misc */3);
    addTasks(self, /* Misc */3, tasks);
    remove(self, /* Misc */3);
    return $$Promise.resolved(true);
  };
  var Queues = {
    spawn: spawn,
    remove: remove,
    addTasks: addTasks,
    countBySource: countBySource,
    getNextTask: getNextTask,
    addMiscTasks: addMiscTasks
  };
  var executeTask = function (self, state, task) {
    if (typeof task === "number") {
      if (task === /* Terminate */0) {
        return $$Promise.map(Curry._1(Task.State.destroy, state), (function (param) {
                      return false;
                    }));
      }
      Belt_Array.forEach(state.decorations, Editor.Decoration.destroy);
      state.decorations = [];
      return $$Promise.resolved(true);
    } else {
      switch (task.tag | 0) {
        case /* DispatchCommand */0 :
            var tasks = Curry._1(CommandHandler.handle, task[0]);
            addTasks(self, /* Command */2, tasks);
            return $$Promise.resolved(true);
        case /* SendRequest */1 :
            if (MultiQueue$AgdaModeVscode.countBySource(self.queues, /* Agda */0) > 0) {
              return $$Promise.resolved(false);
            }
            spawn(self, /* Agda */0);
            var lastTasks = [];
            $$Promise.get($$Promise.map(sendAgdaRequest((function (tasks) {
                            addTasks(self, /* Agda */0, tasks);
                            return kickStart(self, state);
                          }), (function (priority, tasks) {
                            lastTasks.push(/* tuple */[
                                  priority,
                                  tasks
                                ]);
                            
                          }), state, task[0]), (function (param) {
                        var tasks = Belt_List.concatMany(Belt_Array.map(lastTasks.sort((function (x, y) {
                                        return Caml_primitive.caml_int_compare(x[0], y[0]);
                                      })), (function (prim) {
                                    return prim[1];
                                  })));
                        addTasks(self, /* Agda */0, tasks);
                        return kickStart(self, state);
                      })), (function (param) {
                    return remove(self, /* Agda */0);
                  }));
            return $$Promise.resolved(true);
        case /* SendEventToView */2 :
            spawn(self, /* View */1);
            return $$Promise.map(Curry._2(Task.State.sendEventToView, state, task[0]), (function (param) {
                          remove(self, /* View */1);
                          return true;
                        }));
        case /* SendRequestToView */3 :
            var callback = task[1];
            if (MultiQueue$AgdaModeVscode.countBySource(self.queues, /* View */1) > 0) {
              return $$Promise.resolved(false);
            } else {
              spawn(self, /* View */1);
              return $$Promise.map($$Promise.map(Curry._2(Task.State.sendRequestToView, state, task[0]), (function (response) {
                                if (response !== undefined) {
                                  return addTasks(self, /* View */1, Curry._1(callback, response));
                                }
                                
                              })), (function (param) {
                            remove(self, /* View */1);
                            return true;
                          }));
            }
        case /* AddHighlightings */4 :
            Belt_Array.forEach(task[0], (function (highlighting) {
                    var decorations = Curry._2(Decoration.decorateHighlighting, state.editor, highlighting);
                    state.decorations = Belt_Array.concat(state.decorations, decorations);
                    
                  }));
            return $$Promise.resolved(true);
        case /* Error */5 :
            var tasks$1 = Curry._1(ErrorHandler.handle, task[0]);
            return addMiscTasks(self, tasks$1);
        case /* Goal */6 :
            var tasks$2 = Curry._1(GoalHandler.handle, task[0]);
            return addMiscTasks(self, tasks$2);
        case /* WithState */7 :
            Curry._1(task[0], state);
            return $$Promise.resolved(true);
        case /* WithStateP */8 :
            spawn(self, /* Misc */3);
            return $$Promise.map($$Promise.tap($$Promise.map(Curry._1(task[0], state), (function (param) {
                                  return addTasks(self, /* Misc */3, param);
                                })), (function (param) {
                              return remove(self, /* Misc */3);
                            })), (function (param) {
                          return true;
                        }));
        case /* Debug */9 :
            console.log("DEBUG " + task[0]);
            return $$Promise.resolved(true);
        
      }
    }
  };
  var kickStart = function (self, state) {
    if (self.busy) {
      return ;
    }
    var task = getNextTask(self);
    if (task !== undefined) {
      self.busy = true;
      return $$Promise.get(executeTask(self, state, task), (function (keepRunning) {
                    self.busy = false;
                    if (keepRunning) {
                      return kickStart(self, state);
                    }
                    
                  }));
    }
    
  };
  var Runner = {
    make: make,
    Queues: Queues,
    executeTask: executeTask,
    kickStart: kickStart
  };
  var make$1 = function (param) {
    return {
            blocking: {
              queues: MultiQueue$AgdaModeVscode.make(undefined),
              busy: false
            },
            critical: {
              queues: MultiQueue$AgdaModeVscode.make(undefined),
              busy: false
            }
          };
  };
  var dispatchCommand = function (self, state, command) {
    Curry._1(log, "\n\n" + (MultiQueue$AgdaModeVscode.toString(Task.toString, self.critical.queues) + ("\n----------------------------\n" + MultiQueue$AgdaModeVscode.toString(Task.toString, self.blocking.queues))));
    var exit = 0;
    if (typeof command === "number") {
      switch (command) {
        case /* NextGoal */7 :
        case /* PreviousGoal */8 :
        case /* Escape */14 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    } else {
      switch (command.tag | 0) {
        case /* EventFromView */8 :
        case /* InputMethod */13 :
            exit = 2;
            break;
        default:
          exit = 1;
      }
    }
    switch (exit) {
      case 1 :
          addTasks(self.blocking, /* Command */2, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                  /* [] */0
                ]));
          return kickStart(self.blocking, state);
      case 2 :
          addTasks(self.critical, /* Command */2, /* :: */Caml_chrome_debugger.simpleVariant("::", [
                  /* DispatchCommand */Caml_chrome_debugger.variant("DispatchCommand", 0, [command]),
                  /* [] */0
                ]));
          return kickStart(self.critical, state);
      
    }
  };
  var destroy = function (param) {
    
  };
  return {
          Decoration: Decoration,
          ConnM: ConnM,
          ErrorHandler: ErrorHandler,
          GoalHandler: GoalHandler,
          CommandHandler: CommandHandler,
          ResponseHandler: ResponseHandler,
          Task: Task,
          sendAgdaRequest: sendAgdaRequest,
          printLog: false,
          log: log,
          Runner: Runner,
          make: make$1,
          dispatchCommand: dispatchCommand,
          destroy: destroy
        };
}

exports.Impl = Impl;
/* Promise Not a pure module */
